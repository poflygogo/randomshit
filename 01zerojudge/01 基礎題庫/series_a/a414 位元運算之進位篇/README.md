## 解題紀錄
### v1.0 TLE(3s)
- 用 format(int, 'b') 做出字符串格式的二進制數字，再用 zip() 比較每一位數的差別
> for 循環太多位數了，只要有進位就是連續進位，一停下來後就再也不進位了，所以不一定要遍歷完

### v1.1 AC(1s, 20MB)
- 用 v4 的思路做，不 zip() 了

### v2 AC(1.8s, 20.3MB)
- 添加一些條件判斷，避免非必要的循環
> 1.8s 好慢啊，而且吃掉好多記憶體

### v3 AC(1s, 20MB) 	
- 單純只是想要把十進位數字轉換成二進位的話，`bin()` 有效率上的優勢(大約差 2 倍)
> 占用的記憶體依然沒有壓住，仍有待加強

### v4 AC(0.8s, 20MB)
- 目標是求從右側開始連續的 1 的數量，所以可以借助 `rstrip()` ，把所有 1 都去掉，然後比較前後字串的長度即可
> 速度又變快了，但記憶體還是好重......

### v5 AC(0.9s, 20.2MB)
- 取 num + 1 二進位後的值，反轉後直接找 1 的 index 位置就是答案(因為只會返回第一個1的位置)
> 看來該放棄對字串進行操作了，好想減少記憶體消耗阿!!

### v6.0 TLE
- 嘗試全程不使用 string 類型的變量
> 可以得到正解，但太慢了，也許可以嘗試提前結束循環

### v6.1 AC(1.1s, 20.1MB)
- 調整 v6.0 的寫法，提早結束 `while` 循環
> 占用的記憶體還是壓不下去......那些不到 5MB 的人是如何做到的?

### v6.2 AC(0.9s, 20MB)
- 不使用 list 保存二進位數字，而是直接數過程中有幾個 1 (list -> int)
> 到底是什麼在吃記憶體?

### v6.3 AC(2.8s, 3.3MB)
- 改用最樸素的 `input()` 和 `print()`
> 占用的記憶體瞬間變成 3.3MB 而已，導包占用這麼多資源?

> 也是目前唯一不導 sys 不會 TLE 的寫法

### v6.4 AC(0.9s, 20MB) 
- 改使用 `import sys`，而非習慣的 `from sys import stdin, stdout`
> 所以佔空間的是導包的部分 hmm

### v7 TLE
- 改寫 v4 的寫法(目前最快的算法)，使用 imput() print() 取代 sys
> 吃 TLE 是我沒想到的

### v8 AC(1s, 4.7MB)
- 不導入 sys.stdout，只用樸素的 print()
> 占用記憶體的元凶居然是 sys.stdout，一進場就保證吃 15MB ?

## 佔用記憶體的原因
和底層 I/O 操作有關

[細節在此](../../../../other/02python相關/語法/package/sys/sdtout與print()比較.md)