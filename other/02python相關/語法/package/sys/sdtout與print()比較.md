# stdout 與 print() 比較

> python 不太需要關注這個，但我還是先記錄下來

兩者都能用於輸出資料，將結果展示到畫面中，但展示的方式略有不同

當他們接收到資料時，其實並非立即輸出，實際流程是
1. 接收資料 (`print()` 還會把資料先加工一下)
2. 把資料放進去緩衝區 (一般來說就是記憶體)
3. 最後把資料 flush() 出來

這就是所謂的 I/O 操作

## 更細節一點的說

### print()
1. 格式化輸出:<br>
print() 函數會先將你傳入的參數按照指定的格式進行處理，比如轉換為字串、添加分隔符等。
2. 緩衝區寫入:<br>
格式化後的字串會被寫入到一個緩衝區中。這個緩衝區通常是操作系統提供的，用於暫存要輸出的資料。
3. 緩衝區管理:<br>
未指定 flush 時： Python 解釋器會根據系統配置或內部策略，決定何時將緩衝區中的資料刷新到實際的輸出設備（如終端、檔案）。這通常涉及到以下幾種情況：
    - 緩衝區滿： 當緩衝區被填滿時，會自動觸發刷新操作。
    - 遇到換行符： 在某些系統或配置下，遇到換行符時會觸發刷新。
    - 程式結束： 當程式結束時，未刷新的緩衝區會被強制刷新。
4. 系統調用:<br>
實際的刷新操作會涉及到系統調用，將緩衝區中的資料寫入到底層的輸出設備。

### stdout.write()
1. 寫入緩衝區：<br>
當您使用 stdin.write() 時，您所提供的字串並不會立即被輸出到螢幕或檔案。相反，它會被寫入到操作系統提供的輸入緩衝區中。
2. 等待讀取：<br>
只有當另一個程式或進程從這個緩衝區中讀取資料時，這些資料才會被處理。
3. 刷新緩衝區:<br>
    - 程式執行結束時
    - 緩衝區滿了: 當輸入緩衝區被填滿時，為了騰出空間接收新的輸入，系統會自動將緩衝區中的內容傳給下一個處理程式。
    - 遇到特殊字符: 在某些情況下，遇到特定的字符（如換行符）可能會觸發緩衝區的刷新。
    - 程式主動調用 flush():　通過調用 stdin.flush() 來強制將緩衝區中的內容立即傳給下一個處理程式。

### 簡而言之
print() 對記憶體操作的部分是全自動的，會自己處理，而 stdout.write() 則是要使用者自己操作

## 調用 flush() 的代價
涉及到底層的 I/O 操作，I/O 的效率比較低，如果頻繁調用的話會顯著降低效率，所以才需要緩衝區，將資料先累積一些後才調用 I/O，以提升效率。

這也是為什麼 stdout.write() 在實際執行時，效率會明顯比 print()高的原因

如果使用者沒有刻意調用 stdout.flush()，程式會將資料通通都放在緩衝區，最後一口氣一起輸出，可能就只會調用一次 flush()，代價是占用的記憶體比較多。

print() 則是自動的動態調整，根據記憶體狀態，自己調整調用 flush()的頻率，效率可能會略慢於 stdout.write ，但消耗的記憶體會比較少。

> 以空間換時間 vs 以時間換空間