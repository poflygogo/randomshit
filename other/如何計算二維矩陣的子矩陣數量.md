# 求二維矩陣的子矩陣數量
## 方法
- 組合數學：
    - 如果矩陣大小為 m x n，那麼子矩陣的數量等於從 m 行中選擇任意行數，再從 n 列中選擇任意列數的所有組合的數量。
    - 這個問題可以轉化為組合數學中的問題，使用組合公式計算。
- 枚舉法：
    - 對於較小的矩陣，可以通過枚舉所有可能的子矩陣來計算數量。
    - 這種方法對於大規模矩陣計算效率較低。
- 動態規劃：
    - 可以設計動態規劃的狀態轉移方程，通過遞歸計算子矩陣的數量。

# 如果想求一個二維矩陣中，有多少的被標記出來的子矩陣

- 被標記子矩陣： 矩陣中，所有元素都滿足某一特定條件（例如，值為1）的子矩陣。
- 目標： 計算滿足上述條件的所有子矩陣的數量。

## 解方
- 前綴和：
    - 思想： 將原矩陣轉換為一個前綴和矩陣。前綴和矩陣的每個元素表示對應位置左上角的所有元素的和。
    - 優勢： 可以快速計算任意子矩陣的和。
    - 步驟：
        1. 計算前綴和矩陣。
        2. 對於每個元素，枚舉以它為右下角的子矩陣。
        3. 如果一個子矩陣的所有元素都被標記（即前綴和滿足特定條件），則計數。

- 掃描線 + 棧：
    - 思想： 對於每一行，維護一個單調棧，存儲每個元素向左能延伸到的最遠位置。
    - 優勢： 可以快速計算以每個元素為底的矩陣。
    - 步驟：
        1. 對於每一行，使用單調棧找到每個元素向左能延伸到的最遠位置。
        2. 對於每個元素，計算以它為右下角的所有矩形，並判斷是否滿足條件。
- 動態規劃：
    - 思想： 定义状态表示以某个元素为右下角的满足条件的子矩形数量。
    - 優勢： 可以处理更复杂的条件。
    - 步驟：
        - 设计状态转移方程，考虑当前元素是否被标记，以及以其左上角元素为右下角的子矩形数量。

```py
"""
使用前綴和的作法
code by gemini AI 
"""

def count_submatrices(matrix):
    m, n = len(matrix), len(matrix[0])
    # 计算前缀和矩阵
    preSum = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1]

    # 统计满足条件的子矩阵
    count = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            for x in range(1, i + 1):
                for y in range(1, j + 1):
                    if preSum[i][j] - preSum[i - x][j] - preSum[i][j - y] + preSum[i - x][j - y] == x * y:
                        count += 1
    return count
```

## 注意事項
- 边界条件： 注意处理矩阵边界的情况。
- 优化： 可以通过一些优化技巧（例如，二分查找）来提高算法效率。
- 特定条件： 如果对子矩阵有特殊要求（例如，全为1的正方形），可以根据具体条件进行优化。